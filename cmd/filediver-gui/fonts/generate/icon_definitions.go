package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"math"
	"net/http"
	"os"
	"strconv"

	"github.com/iancoleman/strcase"
)

type CodepointDef struct {
	Name      string
	Codepoint rune
}

func getCodepointDefinitions() []CodepointDef {
	var res []CodepointDef
	resp, err := http.Get("https://raw.githubusercontent.com/google/material-design-icons/refs/heads/master/variablefont/MaterialSymbolsOutlined%5BFILL%2CGRAD%2Copsz%2Cwght%5D.codepoints")
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	for line := range bytes.SplitSeq(body, []byte("\n")) {
		line = bytes.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		nameB, codepointB, ok := bytes.Cut(line, []byte(" "))
		if !ok {
			log.Fatalf("invalid line in codepoints file: %s", line)
		}

		codepointI64, err := strconv.ParseInt(string(codepointB), 16, 32)
		if err != nil {
			log.Fatal(err)
		}

		// go-ify name
		name := string(nameB)
		name = strcase.ToCamel(name)
		if len(name) > 0 && name[0] >= '0' && name[0] <= '9' {
			name = "_" + name
		}

		res = append(res, CodepointDef{
			Name:      name,
			Codepoint: rune(codepointI64),
		})
	}
	return res
}

func main() {
	var b bytes.Buffer
	codepoints := getCodepointDefinitions()
	codepointMin := rune(math.MaxInt32)
	codepointMax := rune(math.MinInt32)
	for _, c := range codepoints {
		codepointMin = min(codepointMin, c.Codepoint)
		codepointMax = max(codepointMax, c.Codepoint)
	}
	b.WriteString(`// Code generated by generate/icon_definitions.go; DO NOT EDIT.
package fonts

type _IconDefinitions struct {
`)
	for _, c := range codepoints {
		fmt.Fprintf(&b, "\t%s string\n", c.Name)
	}
	b.WriteString(`}

var I = _IconDefinitions{
`)
	for _, c := range codepoints {
		fmt.Fprintf(&b, "\t%s: \"\\U%08x\",\n", c.Name, c.Codepoint)
	}
	b.WriteString(`}
`)
	formattedCode, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile("icon_definitions.gen.go", formattedCode, 0666); err != nil {
		log.Fatal(err)
	}
}
